<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>RPS Coliseum</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />

  <!-- Coliseum-style font -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&display=swap" rel="stylesheet">

  <!-- p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <!-- p5.sound -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/addons/p5.sound.min.js"></script>
  <!-- socket.io client -->
  <script src="/socket.io/socket.io.js"></script>

  <style>
    body {
      margin: 0;
      padding: 0;
      background:
        radial-gradient(circle at top, #f4e0b2 0, #c7a76a 35%, #5c462b 80%, #261a10 100%);
      color: #fdf4dc;
      font-family: "Cinzel", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
    /* Chat input overlay */
    #chat-input {
      position: fixed;
      right: 32px;
      bottom: 40px;
      width: 22%;
      min-width: 220px;
      padding: 8px 10px;
      font-size: 13px;
      border-radius: 6px;
      border: 1px solid #5b4631;
      background: rgba(26, 17, 9, 0.95);
      color: #fdf4dc;
      outline: none;
      display: none;
      box-shadow: 0 0 8px rgba(0,0,0,0.6);
    }
    #chat-input::placeholder {
      color: #b59a77;
    }
  </style>
</head>
<body>
<input id="chat-input" type="text" placeholder="Type message to opponent..." />
<script>
// ---------------------------
// Assets
// ---------------------------

let imgRock, imgPaper, imgScissors;
let sfxWin, sfxLose, sfxTie, sfxMatchStart, sfxAmbient;
let audioStarted = false;

function preload() {
  imgRock = loadImage('IMM270_Rock.gif');
  imgPaper = loadImage('IMM270_Paper.gif');
  imgScissors = loadImage('IMM270_Scissors.gif');

  if (typeof soundFormats === 'function') {
    soundFormats('mp3', 'wav');
  }
  if (typeof loadSound === 'function') {
    sfxWin = loadSound('IMM270_Win_Sound.mp3');
    sfxLose = loadSound('IMM270_Lose_Sound.wav');
    sfxTie = loadSound('IMM270_Tie_Sound.wav');
    sfxMatchStart = loadSound('IMM270_MatchStart_Sound.wav');
    sfxAmbient = loadSound('IMM270_spectator-and-background_Sound.wav');
  }
}

// ---------------------------
// Client state
// ---------------------------

let socket;
let connectionStatus = 'connecting';

let myPlayer = {
  id: null,
  name: null,
  preferredColor: '#ffcc66',
  totalWins: 0,
  totalLosses: 0
};

let lobbyState = {
  spectators: [],
  activeMatches: [],
  globalStats: { totalMatchesPlayed: 0, totalRoundsPlayed: 0 }
};

let uiMode = 'lobby'; // 'lobby' | 'match' | 'spectate' | 'settings'
let isInQueue = false;

let currentMatch = null;
let viewingMatchAsSpectator = false;

let turnInfo = {
  holderId: null,
  expiresAt: 0,
  durationMs: 30000
};

let lastRoundResult = null;
let rpsButtons = [];
let lobbyButtons = {
  queue: null,
  spectateRandom: null,
  settings: null,
  matches: []
};
let spectateBackButton = null;

let matchChatMessages = [];
let chatInputEl = null;

// Settings: volume + best-of
let volumeLevel = 0.8;
let volumeSlider = null;
let backFromSettingsButton = null;
let bestOfButtons = [];
let bestOfChoice = 3;

// ---------------------------
// Setup & socket
// ---------------------------

function setup() {
  createCanvas(windowWidth, windowHeight);

  let name = prompt("Enter your gladiator name:", "Challenger");
  if (!name || !name.trim()) name = "Challenger";
  myPlayer.name = name.trim().slice(0, 20);
  myPlayer.preferredColor = randomArenaColor();

  chatInputEl = document.getElementById('chat-input');
  chatInputEl.addEventListener('keydown', e => {
    if (e.key === 'Enter') {
      e.preventDefault();
      sendChatMessage();
    }
  });

  initSocket();
  setupHeartbeat();

  textFont('"Cinzel", system-ui');
  textAlign(LEFT, TOP);

  setVolumeLevel(volumeLevel);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function randomArenaColor() {
  const r = floor(random(170, 230)).toString(16).padStart(2, '0');
  const g = floor(random(130, 200)).toString(16).padStart(2, '0');
  const b = floor(random(60, 120)).toString(16).padStart(2, '0');
  return `#${r}${g}${b}`;
}

function initSocket() {
  if (typeof io !== 'function') {
    connectionStatus = 'disconnected';
    console.error('socket.io client failed to load.');
    return;
  }

  socket = io();
  connectionStatus = 'connecting';

  socket.on('connect', () => {
    connectionStatus = 'connected';
    myPlayer.id = socket.id;
    socket.emit('joinLobby', {
      name: myPlayer.name,
      preferredColor: myPlayer.preferredColor,
      joinQueue: false,
      timestamp: Date.now()
    });
    socket.emit('setBestOf', { bestOf: bestOfChoice });
  });

  socket.on('disconnect', () => {
    connectionStatus = 'disconnected';
  });

  socket.on('lobbyState', data => {
    if (!data) return;
    lobbyState.spectators = data.spectators || [];
    lobbyState.activeMatches = data.activeMatches || [];
    lobbyState.globalStats = data.globalStats || lobbyState.globalStats;
    if (!currentMatch && uiMode !== 'settings') uiMode = 'lobby';
  });

  socket.on('match_start', data => {
    if (!data) return;
    uiMode = 'match';
    viewingMatchAsSpectator = false;
    currentMatch = {
      matchId: data.matchId,
      players: data.players || [],
      scores: data.scores || {},
      round: data.round || 1,
      startingPlayer: data.startingPlayer,
      bestOf: data.bestOf || 3
    };
    hasSubmittedMoveThisRound = false;
    lastRoundResult = null;
    matchChatMessages = [];
    turnInfo.holderId = data.startingPlayer;

    if (sfxMatchStart && sfxMatchStart.isLoaded && sfxMatchStart.isLoaded()) {
      sfxMatchStart.setVolume(volumeLevel);
      sfxMatchStart.play();
    }
  });

  socket.on('match_snapshot', data => {
    if (!data) return;
    currentMatch = {
      matchId: data.matchId,
      players: data.players || [],
      scores: data.scores || {},
      round: data.round || 1,
      bestOf: data.bestOf || 3
    };
    uiMode = 'spectate';
    viewingMatchAsSpectator = true;
    lastRoundResult = null;
    matchChatMessages = [];
    turnInfo.holderId = data.turnInfo?.holderId || null;
    turnInfo.expiresAt = data.turnInfo?.expiresAt || 0;
    turnInfo.durationMs = data.turnInfo?.durationMs || 30000;
  });

  socket.on('turnUpdate', data => {
    if (!data) return;
    if (!currentMatch || currentMatch.matchId !== data.matchId) return;
    turnInfo.holderId = data.holderId;
    turnInfo.expiresAt = data.expiresAt;
    turnInfo.durationMs = data.durationMs || 30000;
    hasSubmittedMoveThisRound = false;
  });

  socket.on('round_result', data => {
    if (!data) return;
    if (!currentMatch || currentMatch.matchId !== data.matchId) return;
    currentMatch.round = data.round;
    currentMatch.scores = data.scores;
    lastRoundResult = {
      round: data.round,
      winnerId: data.winnerId,
      reason: data.reason,
      revealedMoves: data.revealedMoves,
      scores: data.scores
    };
    hasSubmittedMoveThisRound = false;

    const myId = socket ? socket.id : null;
    if (!data.winnerId) {
      if (sfxTie && sfxTie.isLoaded && sfxTie.isLoaded()) {
        sfxTie.setVolume(volumeLevel);
        sfxTie.play();
      }
    } else if (myId && data.winnerId === myId) {
      if (sfxWin && sfxWin.isLoaded && sfxWin.isLoaded()) {
        sfxWin.setVolume(volumeLevel);
        sfxWin.play();
      }
    } else {
      if (sfxLose && sfxLose.isLoaded && sfxLose.isLoaded()) {
        sfxLose.setVolume(volumeLevel);
        sfxLose.play();
      }
    }
  });

  socket.on('game_end', data => {
    if (!data) return;
    if (viewingMatchAsSpectator && currentMatch && currentMatch.matchId === data.matchId) {
      currentMatch = null;
      lastRoundResult = null;
      matchChatMessages = [];
      viewingMatchAsSpectator = false;
      uiMode = 'lobby';
    }
  });

  socket.on('chatMessage', data => {
    if (!data) return;
    if (!currentMatch || currentMatch.matchId !== data.matchId) return;
    matchChatMessages.push({
      fromName: data.fromName || '???',
      text: data.text || '',
      timestamp: data.timestamp || Date.now(),
      fromId: data.fromId
    });
    if (matchChatMessages.length > 80) matchChatMessages.shift();
  });
}

function setupHeartbeat() {
  setInterval(() => {
    if (socket && socket.connected) {
      socket.emit('heartbeat', { timestamp: Date.now() });
    }
  }, 5000);
}

// ---------------------------
// Draw loop
// ---------------------------

let hasSubmittedMoveThisRound = false;

function draw() {
  background(0, 0, 0, 0);
  drawColiseumBackdrop();

  drawConnectionStatusBar();

  if (uiMode === 'lobby') {
    drawLobbyUI();
  } else if (uiMode === 'match' || uiMode === 'spectate') {
    drawMatchUI();
  } else if (uiMode === 'settings') {
    drawSettingsUI();
  }

  drawFooterInstructions();
  updateChatInputVisibility();
}

function drawColiseumBackdrop() {
  noStroke();
  // arena floor
  fill(201, 163, 93, 220);
  ellipse(width * 0.33, height * 0.75, width * 0.55, height * 0.35);

  // distant stands
  fill(90, 65, 36, 220);
  rect(0, height * 0.4, width * 0.65, height * 0.05);
  fill(120, 85, 46, 220);
  rect(0, height * 0.45, width * 0.65, height * 0.03);

  // pillars on sides
  fill(150, 126, 84, 240);
  const pW = 18;
  for (let i = 0; i < 6; i++) {
    const px = 20 + i * 40;
    rect(px, height * 0.35, pW, height * 0.35, 6);
  }
}

function drawConnectionStatusBar() {
  const h = 32;
  noStroke();
  fill(40, 26, 16, 220);
  rect(0, 0, width, h);

  let statusText = 'Connecting to the arena...';
  let statusColor = color(255, 222, 130);

  if (connectionStatus === 'connected') {
    statusText = 'Arena gates open';
    statusColor = color(184, 255, 184);
  } else if (connectionStatus === 'disconnected') {
    statusText = 'Disconnected (check server)';
    statusColor = color(255, 140, 140);
  }

  fill(statusColor);
  textSize(14);
  textAlign(LEFT, CENTER);
  text(statusText, 16, h / 2);

  fill(230);
  textAlign(RIGHT, CENTER);
  text(
    myPlayer.name ? `You: ${myPlayer.name}` : 'You: (unnamed)',
    width - 16,
    h / 2
  );
}

function drawLobbyUI() {
  const padding = 24;
  const topOffset = 40;

  textAlign(CENTER, TOP);
  textSize(32);
  fill(252, 237, 196);
  text("ROCK · PAPER · SCISSORS COLISEUM", width / 2, topOffset);

  textSize(14);
  fill(238, 215, 166);
  text(
    "Step into the sand. Enter the challenger queue or roam the stands as a spectator.",
    width / 2,
    topOffset + 40
  );

  const statsY = topOffset + 80;
  fill(236, 211, 166);
  text(
    `Duels fought: ${lobbyState.globalStats.totalMatchesPlayed || 0}  •  Rounds: ${lobbyState.globalStats.totalRoundsPlayed || 0}`,
    width / 2,
    statsY
  );

  const buttonWidth = 220;
  const buttonHeight = 50;
  const centerX = width / 2;
  const buttonsBaseY = statsY + 40;

  const queueX = centerX - buttonWidth - 16;
  const queueY = buttonsBaseY;
  lobbyButtons.queue = { x: queueX, y: queueY, w: buttonWidth, h: buttonHeight };

  const isHoverQueue =
    mouseX >= queueX && mouseX <= queueX + buttonWidth &&
    mouseY >= queueY && mouseY <= queueY + buttonHeight;

  noStroke();
  fill(isHoverQueue
      ? (isInQueue ? color(148, 72, 55) : color(117, 166, 97))
      : (isInQueue ? color(97, 49, 39) : color(74, 127, 68)));
  rect(queueX, queueY, buttonWidth, buttonHeight, 12);

  textAlign(CENTER, CENTER);
  textSize(16);
  fill(253, 244, 212);
  text(isInQueue ? "Leave Challenger Queue" : "Enter Challenger Queue",
       queueX + buttonWidth / 2, queueY + buttonHeight / 2);

  const specX = centerX + 16;
  const specY = buttonsBaseY;
  lobbyButtons.spectateRandom = { x: specX, y: specY, w: buttonWidth, h: buttonHeight };

  const specHover =
    mouseX >= specX && mouseX <= specX + buttonWidth &&
    mouseY >= specY && mouseY <= specY + buttonHeight;

  fill(specHover ? color(106, 116, 178) : color(63, 69, 129));
  rect(specX, specY, buttonWidth, buttonHeight, 12);
  fill(252, 242, 210);
  text("Watch a Random Duel", specX + buttonWidth / 2, specY + buttonHeight / 2);

  const settingsWidth = 130;
  const settingsHeight = 26;
  const settingsX = width - settingsWidth - padding;
  const settingsY = topOffset + 4;
  lobbyButtons.settings = { x: settingsX, y: settingsY, w: settingsWidth, h: settingsHeight };

  const setHover =
    mouseX >= settingsX && mouseX <= settingsX + settingsWidth &&
    mouseY >= settingsY && mouseY <= settingsY + settingsHeight;

  fill(setHover ? 94 : 65);
  rect(settingsX, settingsY, settingsWidth, settingsHeight, 10);
  textSize(13);
  textAlign(CENTER, CENTER);
  fill(240);
  text("⚙ Arena Settings", settingsX + settingsWidth / 2, settingsY + settingsHeight / 2);

  // Left: spectators
  const listY = buttonsBaseY + 80;
  textAlign(LEFT, TOP);
  fill(249, 231, 194);
  textSize(18);
  text("Gladiators in the Hall", padding, listY);

  const lineHeight = 20;
  textSize(14);
  let y = listY + 28;
  lobbyState.spectators.forEach((p, i) => {
    const label = `${p.name}  (W: ${p.totalWins || 0}, L: ${p.totalLosses || 0})`;
    fill(234, 214, 179);
    text(label, padding, y + i * lineHeight);
  });

  // Right: matches
  const matchesX = width * 0.5 + 40;
  fill(248, 231, 191);
  textSize(18);
  text("Duels in the Arena", matchesX, listY);

  y = listY + 32;
  lobbyButtons.matches = [];
  lobbyState.activeMatches.forEach((m, i) => {
    const pA = m.players[0]?.name || "Gladiator A";
    const pB = m.players[1]?.name || "Gladiator B";
    const sA = m.scores[m.players[0]?.id] || 0;
    const sB = m.scores[m.players[1]?.id] || 0;

    const rowY = y + i * (lineHeight + 10);
    const rowW = width - matchesX - padding;
    const rowH = lineHeight + 8;

    const rowHover =
      mouseX >= matchesX && mouseX <= matchesX + rowW &&
      mouseY >= rowY && mouseY <= rowY + rowH;

    noStroke();
    fill(rowHover ? color(92, 68, 43, 230) : color(63, 47, 31, 220));
    rect(matchesX, rowY, rowW, rowH, 8);

    fill(239, 221, 184);
    textSize(14);
    text(
      `${pA} (${sA}) vs ${pB} (${sB})  ·  Best of ${m.bestOf || 3}`,
      matchesX + 8,
      rowY + 4
    );

    lobbyButtons.matches.push({
      x: matchesX,
      y: rowY,
      w: rowW,
      h: rowH,
      matchId: m.matchId
    });
  });
}

function drawMatchUI() {
  if (!currentMatch) {
    uiMode = 'lobby';
    return;
  }

  const topOffset = 40;

  const myId = socket ? socket.id : null;
  const [pA, pB] = currentMatch.players || [];
  const isPlayerA = myId && pA && pA.id === myId;
  const isPlayerB = myId && pB && pB.id === myId;
  const isParticipant = isPlayerA || isPlayerB;
  viewingMatchAsSpectator = !isParticipant;

  const scoreA = currentMatch.scores[pA?.id] || 0;
  const scoreB = currentMatch.scores[pB?.id] || 0;
  const nameA = pA ? pA.name : "Gladiator A";
  const nameB = pB ? pB.name : "Gladiator B";

  const chatWidth = max(width * 0.25, 260);
  const chatX = width - chatWidth - 20;
  const arenaLeft = 20;
  const arenaRight = chatX - 20;
  const arenaWidth = max(200, arenaRight - arenaLeft);
  const arenaCenterX = arenaLeft + arenaWidth / 2;

  textAlign(CENTER, TOP);
  textSize(22);
  fill(252, 237, 196);
  text(`Arena Duel · Best of ${currentMatch.bestOf || 3}`, arenaLeft + arenaWidth / 2, topOffset);

  spectateBackButton = null;
  if (viewingMatchAsSpectator) {
    const bX = arenaLeft;
    const bY = topOffset + 4;
    const bW = 150;
    const bH = 26;
    spectateBackButton = { x: bX, y: bY, w: bW, h: bH };

    const hover =
      mouseX >= bX && mouseX <= bX + bW &&
      mouseY >= bY && mouseY <= bY + bH;

    noStroke();
    fill(hover ? 94 : 67);
    rect(bX, bY, bW, bH, 8);
    textAlign(CENTER, CENTER);
    textSize(13);
    fill(245, 230, 196);
    text("← Back to Hall", bX + bW / 2, bY + bH / 2);
  }

  textSize(16);
  textAlign(CENTER, TOP);
  fill(242, 222, 187);
  text(
    `${nameA}  (Score: ${scoreA})`,
    arenaLeft + arenaWidth * 0.25,
    topOffset + 40
  );
  text(
    `${nameB}  (Score: ${scoreB})`,
    arenaLeft + arenaWidth * 0.75,
    topOffset + 40
  );

  textSize(14);
  if (isPlayerA) {
    fill(185, 255, 185);
    text("(You)", arenaLeft + arenaWidth * 0.25, topOffset + 60);
  }
  if (isPlayerB) {
    fill(185, 255, 185);
    text("(You)", arenaLeft + arenaWidth * 0.75, topOffset + 60);
  }

  textAlign(CENTER, TOP);
  textSize(18);
  fill(245, 228, 191);
  text(`Round ${currentMatch.round}`, arenaCenterX, topOffset + 90);

  drawTurnTimerBar(arenaLeft, arenaWidth);
  if (isParticipant && uiMode === 'match') {
    drawRPSButtons(arenaLeft, arenaWidth);
  } else {
    rpsButtons = [];
  }
  drawRoundResultPanel(arenaLeft, arenaWidth);
  drawChatPanel(chatX, chatWidth, isParticipant);
}

function drawTurnTimerBar(arenaLeft, arenaWidth) {
  const barWidth = arenaWidth - 60;
  const barHeight = 16;
  const x = arenaLeft + (arenaWidth - barWidth) / 2;
  const y = 140;

  const now = Date.now();
  const remaining = max(0, turnInfo.expiresAt - now);
  const totalMs = turnInfo.durationMs || 30000;
  const progress = constrain(remaining / totalMs, 0, 1);

  noStroke();
  fill(55, 39, 25);
  rect(x, y, barWidth, barHeight, 8);

  if (progress > 0) {
    fill(204, 176, 115);
    rect(x, y, barWidth * progress, barHeight, 8);
  }

  const holderId = turnInfo.holderId;
  const currentPlayer = currentMatch.players?.find(p => p.id === holderId);
  const holderName = currentPlayer ? currentPlayer.name : 'Both fighters';

  textAlign(CENTER, CENTER);
  textSize(12);
  fill(248, 234, 201);
  const seconds = (remaining / 1000).toFixed(1);
  text(
    `Turn: ${holderName}   •   Time left: ${seconds}s`,
    arenaLeft + arenaWidth / 2,
    y + barHeight + 14
  );
}

function drawRPSButtons(arenaLeft, arenaWidth) {
  const baseY = height - 150;
  const totalWidth = min(arenaWidth * 0.9, 520);
  const buttonWidth = totalWidth / 3 - 16;
  const buttonHeight = 80;
  const startX = arenaLeft + (arenaWidth - totalWidth) / 2;

  const labels = ['Rock', 'Paper', 'Scissors'];
  const moves = ['rock', 'paper', 'scissors'];

  rpsButtons = [];

  for (let i = 0; i < 3; i++) {
    const x = startX + i * (buttonWidth + 16);
    const y = baseY;
    rpsButtons.push({ x, y, w: buttonWidth, h: buttonHeight, move: moves[i] });

    const hover =
      mouseX >= x && mouseX <= x + buttonWidth &&
      mouseY >= y && mouseY <= y + buttonHeight;

    noStroke();
    fill(hover ? color(140, 108, 72) : color(102, 77, 50));
    rect(x, y, buttonWidth, buttonHeight, 14);

    let img = null;
    if (moves[i] === 'rock') img = imgRock;
    else if (moves[i] === 'paper') img = imgPaper;
    else if (moves[i] === 'scissors') img = imgScissors;

    if (img) {
      const iconSize = min(buttonWidth - 12, buttonHeight - 12);
      image(
        img,
        x + (buttonWidth - iconSize) / 2,
        y + (buttonHeight - iconSize) / 2,
        iconSize,
        iconSize
      );
    }

    textAlign(CENTER, BOTTOM);
    textSize(14);
    fill(252, 238, 203);
    text(labels[i], x + buttonWidth / 2, y - 4);
  }

  textAlign(CENTER, TOP);
  textSize(13);
  fill(240, 219, 177);
  text("Choose your move before the horn sounds.", arenaLeft + arenaWidth / 2, baseY - 32);
}

function drawRoundResultPanel(arenaLeft, arenaWidth) {
  const panelWidth = arenaWidth - 40;
  const panelHeight = 150;
  const x = arenaLeft + (arenaWidth - panelWidth) / 2;
  const y = 200;

  noStroke();
  fill(56, 39, 25, 235);
  rect(x, y, panelWidth, panelHeight, 16);

  textAlign(LEFT, TOP);
  textSize(16);
  fill(248, 234, 200);
  text("Last Clash", x + 16, y + 10);

  textSize(13);
  if (!lastRoundResult) {
    fill(222, 204, 168);
    text("No rounds resolved yet. Moves will be revealed once both fighters choose.", x + 16, y + 40);
    return;
  }

  const { winnerId, reason, revealedMoves } = lastRoundResult;

  let reasonText = '';
  if (reason === 'moves') reasonText = 'Normal resolution';
  else if (reason === 'timeout') reasonText = 'Timeout: inactive fighter lost';
  else if (reason === 'disconnect') reasonText = 'Opponent left the arena';
  else if (reason === 'forfeit') reasonText = 'Someone yielded';

  const myId = socket ? socket.id : null;
  let outcome = 'Tie';
  if (winnerId && myId) {
    if (winnerId === myId) outcome = 'You prevailed!';
    else outcome = 'You were defeated.';
  }

  fill(236, 218, 180);
  text(`Outcome: ${outcome}`, x + 16, y + 40);
  text(`Reason: ${reasonText}`, x + 16, y + 60);

  if (revealedMoves && currentMatch && currentMatch.players) {
    const [pA, pB] = currentMatch.players;
    const moveA = pA ? revealedMoves[pA.id] : null;
    const moveB = pB ? revealedMoves[pB.id] : null;

    const iconSize = 52;
    const midY = y + 105;
    const leftX = x + panelWidth * 0.25 - iconSize / 2;
    const rightX = x + panelWidth * 0.75 - iconSize / 2;

    function imgForMove(m) {
      if (m === 'rock') return imgRock;
      if (m === 'paper') return imgPaper;
      if (m === 'scissors') return imgScissors;
      return null;
    }

    if (pA) {
      const imgA = imgForMove(moveA);
      if (imgA) image(imgA, leftX, midY - iconSize / 2, iconSize, iconSize);
      textAlign(CENTER, TOP);
      fill(240, 224, 191);
      text(pA.name, x + panelWidth * 0.25, midY + iconSize / 2 + 4);
    }

    if (pB) {
      const imgB = imgForMove(moveB);
      if (imgB) image(imgB, rightX, midY - iconSize / 2, iconSize, iconSize);
      textAlign(CENTER, TOP);
      fill(240, 224, 191);
      text(pB.name, x + panelWidth * 0.75, midY + iconSize / 2 + 4);
    }
  }
}

function drawChatPanel(chatX, chatWidth, isParticipant) {
  const panelWidth = chatWidth;
  const panelHeight = height - 200;
  const x = chatX;
  const y = 180;

  noStroke();
  fill(42, 29, 18, 240);
  rect(x, y, panelWidth, panelHeight, 16);

  textAlign(LEFT, TOP);
  textSize(15);
  fill(248, 234, 200);
  text("Arena Chatter", x + 12, y + 10);

  textSize(11);
  fill(215, 192, 151);
  text(
    isParticipant ? "Speak to your opponent. Spectators can only read."
                  : "You are a spectator in the stands.",
    x + 12,
    y + 28
  );

  const textAreaY = y + 48;
  const textAreaH = panelHeight - 56;
  let lineY = textAreaY;
  const lineStep = 14;

  const maxLines = floor(textAreaH / lineStep);
  const recent = matchChatMessages.slice(-maxLines);

  for (const msg of recent) {
    const prefix = msg.fromName + ": ";
    const fullText = prefix + msg.text;
    fill(239, 220, 186);
    text(fullText, x + 10, lineY);
    lineY += lineStep;
  }
}

function drawSettingsUI() {
  const padding = 24;
  textAlign(CENTER, TOP);
  textSize(24);
  fill(252, 237, 196);
  text("Arena Settings", width / 2, padding + 16);

  const panelWidth = min(520, width - 80);
  const panelHeight = 260;
  const x = (width - panelWidth) / 2;
  const y = (height - panelHeight) / 2;

  noStroke();
  fill(52, 36, 23, 240);
  rect(x, y, panelWidth, panelHeight, 16);

  textAlign(LEFT, TOP);
  textSize(16);
  fill(246, 229, 193);
  text("Arena Volume", x + 24, y + 24);

  const sliderX = x + 24;
  const sliderY = y + 80;
  const sliderW = panelWidth - 48;
  const sliderH = 10;
  volumeSlider = { x: sliderX, y: sliderY - sliderH / 2, w: sliderW, h: sliderH * 2 };

  noStroke();
  fill(76, 55, 36);
  rect(sliderX, sliderY - sliderH / 2, sliderW, sliderH, 6);

  const knobX = sliderX + volumeLevel * sliderW;
  const knobRadius = 9;
  fill(204, 176, 115);
  ellipse(knobX, sliderY, knobRadius * 2, knobRadius * 2);

  textAlign(LEFT, TOP);
  textSize(14);
  fill(230, 210, 175);
  text(`Volume: ${(volumeLevel * 100).toFixed(0)}%`, x + 24, y + 104);

  // Best-of selection
  textSize(16);
  fill(246, 229, 193);
  text("Match Length (Best of)", x + 24, y + 140);

  bestOfButtons = [];
  const options = [3, 5, 7];
  const btnW = 80;
  const btnH = 30;
  let bx = x + 24;
  const by = y + 170;

  options.forEach(val => {
    const hover =
      mouseX >= bx && mouseX <= bx + btnW &&
      mouseY >= by && mouseY <= by + btnH;

    const selected = bestOfChoice === val;
    fill(selected ? color(143, 110, 69) : hover ? color(95, 70, 45) : color(70, 52, 33));
    rect(bx, by, btnW, btnH, 8);
    textAlign(CENTER, CENTER);
    textSize(14);
    fill(244, 228, 196);
    text(`Best of ${val}`, bx + btnW / 2, by + btnH / 2);

    bestOfButtons.push({ x: bx, y: by, w: btnW, h: btnH, value: val });
    bx += btnW + 12;
  });

  const bW = 140;
  const bH = 32;
  const bX = x + panelWidth / 2 - bW / 2;
  const bY = y + panelHeight - bH - 18;
  backFromSettingsButton = { x: bX, y: bY, w: bW, h: bH };

  const hover =
    mouseX >= bX && mouseX <= bX + bW &&
    mouseY >= bY && mouseY <= bY + bH;

  fill(hover ? 94 : 67);
  rect(bX, bY, bW, bH, 10);
  textAlign(CENTER, CENTER);
  textSize(14);
  fill(244, 228, 196);
  text("Back to Hall", bX + bW / 2, bY + bH / 2);
}

function drawFooterInstructions() {
  const footerY = height - 28;
  noStroke();
  fill(40, 26, 16, 230);
  rect(0, footerY, width, 28);

  textAlign(CENTER, CENTER);
  textSize(12);
  fill(233, 211, 172);
  if (uiMode === 'lobby') {
    text("Main Hall: enter the challenger queue or watch ongoing duels from the stands.",
         width / 2, footerY + 14);
  } else if (uiMode === 'match') {
    text("Match: choose Rock / Paper / Scissors before time runs out. Press 'L' to yield the duel.",
         width / 2, footerY + 14);
  } else if (uiMode === 'spectate') {
    text("Spectating: observe the duel and read the arena chatter. Use the back button to return.",
         width / 2, footerY + 14);
  } else if (uiMode === 'settings') {
    text("Settings: tune the roar of the crowd and how long duels last.",
         width / 2, footerY + 14);
  }
}

// ---------------------------
// Input & audio
// ---------------------------

function startAudioIfNeeded() {
  if (!audioStarted) {
    audioStarted = true;
    if (typeof userStartAudio === 'function') userStartAudio();
    if (sfxAmbient &&
        sfxAmbient.isLoaded && sfxAmbient.isLoaded() &&
        sfxAmbient.isPlaying && !sfxAmbient.isPlaying()) {
      sfxAmbient.setLoop(true);
      sfxAmbient.setVolume(0.35 * volumeLevel);
      sfxAmbient.play();
    }
  }
}

function mousePressed() {
  startAudioIfNeeded();

  if (uiMode === 'match') {
    if (!viewingMatchAsSpectator) handleRPSClick();
    handleMatchCommonClick();
  } else if (uiMode === 'spectate') {
    handleMatchCommonClick();
  } else if (uiMode === 'lobby') {
    handleLobbyClick();
  } else if (uiMode === 'settings') {
    handleSettingsClick();
  }
}

function handleRPSClick() {
  if (!currentMatch || !socket || !socket.connected) return;
  if (hasSubmittedMoveThisRound) return;
  if (Date.now() > turnInfo.expiresAt) return;

  for (const btn of rpsButtons) {
    if (
      mouseX >= btn.x && mouseX <= btn.x + btn.w &&
      mouseY >= btn.y && mouseY <= btn.y + btn.h
    ) {
      socket.emit('playerMove', {
        matchId: currentMatch.matchId,
        move: btn.move,
        timestamp: Date.now()
      });
      hasSubmittedMoveThisRound = true;
      break;
    }
  }
}

function handleMatchCommonClick() {
  if (viewingMatchAsSpectator && spectateBackButton) {
    const b = spectateBackButton;
    if (
      mouseX >= b.x && mouseX <= b.x + b.w &&
      mouseY >= b.y && mouseY <= b.y + b.h
    ) {
      if (socket && socket.connected) {
        socket.emit('leaveSpectate');
      }
      currentMatch = null;
      lastRoundResult = null;
      matchChatMessages = [];
      viewingMatchAsSpectator = false;
      uiMode = 'lobby';
    }
  }
}

function handleLobbyClick() {
  if (!socket || !socket.connected) return;

  const q = lobbyButtons.queue;
  if (q &&
    mouseX >= q.x && mouseX <= q.x + q.w &&
    mouseY >= q.y && mouseY <= q.y + q.h) {
    isInQueue = !isInQueue;
    socket.emit('setQueueStatus', {
      inQueue: isInQueue,
      timestamp: Date.now()
    });
    return;
  }

  const s = lobbyButtons.spectateRandom;
  if (s &&
    mouseX >= s.x && mouseX <= s.x + s.w &&
    mouseY >= s.y && mouseY <= s.y + s.h) {
    if (lobbyState.activeMatches.length > 0) {
      const m = lobbyState.activeMatches[0];
      requestSpectateMatch(m.matchId);
    }
    return;
  }

  const set = lobbyButtons.settings;
  if (set &&
    mouseX >= set.x && mouseX <= set.x + set.w &&
    mouseY >= set.y && mouseY <= set.y + set.h) {
    uiMode = 'settings';
    return;
  }

  for (const row of lobbyButtons.matches) {
    if (
      mouseX >= row.x && mouseX <= row.x + row.w &&
      mouseY >= row.y && mouseY <= row.y + row.h
    ) {
      requestSpectateMatch(row.matchId);
      return;
    }
  }
}

function requestSpectateMatch(matchId) {
  if (!socket || !socket.connected) return;
  if (!matchId) return;
  socket.emit('spectateMatch', {
    matchId,
    timestamp: Date.now()
  });
}

function handleSettingsClick() {
  if (volumeSlider) {
    const s = volumeSlider;
    if (
      mouseX >= s.x && mouseX <= s.x + s.w &&
      mouseY >= s.y && mouseY <= s.y + s.h
    ) {
      const t = constrain((mouseX - s.x) / s.w, 0, 1);
      setVolumeLevel(t);
    }
  }

  for (const btn of bestOfButtons) {
    if (
      mouseX >= btn.x && mouseX <= btn.x + btn.w &&
      mouseY >= btn.y && mouseY <= btn.y + btn.h
    ) {
      bestOfChoice = btn.value;
      if (socket && socket.connected) {
        socket.emit('setBestOf', { bestOf: bestOfChoice });
      }
    }
  }

  if (backFromSettingsButton) {
    const b = backFromSettingsButton;
    if (
      mouseX >= b.x && mouseX <= b.x + b.w &&
      mouseY >= b.y && mouseY <= b.y + b.h
    ) {
      uiMode = 'lobby';
    }
  }
}

function keyPressed() {
  startAudioIfNeeded();
  if (!socket || !socket.connected) return;

  if (key === 'l' || key === 'L') {
    if (uiMode === 'match' && currentMatch) {
      socket.emit('leaveMatch', { timestamp: Date.now() });
      currentMatch = null;
      lastRoundResult = null;
      matchChatMessages = [];
      uiMode = 'lobby';
    }
  }
}

// ---------------------------
// Chat & volume
// ---------------------------

function sendChatMessage() {
  if (!chatInputEl) return;
  if (!socket || !socket.connected || !currentMatch) return;
  if (!currentMatch.players || !socket.id) return;

  const isParticipant = currentMatch.players.some(p => p.id === socket.id);
  if (!isParticipant) return;

  const text = chatInputEl.value.trim();
  if (!text) return;

  socket.emit('chatMessage', {
    matchId: currentMatch.matchId,
    text,
    timestamp: Date.now()
  });

  chatInputEl.value = '';
}

function updateChatInputVisibility() {
  if (!chatInputEl) return;

  const shouldShow = (uiMode === 'match' || uiMode === 'spectate') && !!currentMatch;
  chatInputEl.style.display = shouldShow ? 'block' : 'none';

  if (!shouldShow) return;

  const isParticipant =
    currentMatch &&
    socket &&
    currentMatch.players &&
    currentMatch.players.some(p => p.id === socket.id);

  chatInputEl.disabled = !isParticipant;
  chatInputEl.placeholder = isParticipant
    ? "Speak your mind and press Enter..."
    : "Spectators cannot chat.";
}

function setVolumeLevel(t) {
  volumeLevel = constrain(t, 0, 1);

  if (typeof masterVolume === 'function') {
    masterVolume(volumeLevel);
  }

  const sfxArray = [sfxWin, sfxLose, sfxTie, sfxMatchStart];
  sfxArray.forEach(s => {
    if (s && typeof s.setVolume === 'function') {
      s.setVolume(volumeLevel);
    }
  });

  if (sfxAmbient && typeof sfxAmbient.setVolume === 'function') {
    sfxAmbient.setVolume(0.35 * volumeLevel);
  }
}
</script>
</body>
</html>