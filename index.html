<!-- index.html -->
<!--
  Rock-Paper-Scissors Coliseum
  Client built with p5.js + socket.io
  - Open multiple tabs to test multiplayer.
  - Click the Rock / Paper / Scissors buttons during a match.
  - Press 'L' to leave (forfeit) a match.
-->

<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>RPS Coliseum</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <!-- p5.js -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.9.0/p5.min.js"></script>
  <!-- socket.io client from the server -->
  <script src="/socket.io/socket.io.js"></script>
  <style>
    body {
      margin: 0;
      padding: 0;
      background: #111;
      color: #eee;
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overflow: hidden;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<script>
// ---------------------------
// Client-side global state
// ---------------------------

let socket;
let connectionStatus = 'connecting'; // 'connecting' | 'connected' | 'disconnected' | 'reconnecting'

let myPlayer = {
  id: null,
  name: null,
  preferredColor: '#ff00ff',
  totalWins: 0,
  totalLosses: 0
};

let lobbyState = {
  spectators: [],
  activeMatches: [],
  globalStats: { totalMatchesPlayed: 0, totalRoundsPlayed: 0 }
};

let currentMatch = null; // snapshot of the current match for this client
let turnInfo = {
  holderId: null,
  expiresAt: 0
};
let lastRoundResult = null; // { winnerId, reason, round, revealedMoves, scores }

let uiMode = 'lobby'; // 'lobby' | 'match'
let hasSubmittedMoveThisRound = false;

// Button bounds for R/P/S in match UI
let rpsButtons = [];

// ---------------------------
// Setup & socket connection
// ---------------------------

function setup() {
  createCanvas(windowWidth, windowHeight);

  // Ask for a name once
  let name = prompt("Enter your gladiator name:", "Player");
  if (!name || !name.trim()) {
    name = "Player";
  }
  myPlayer.name = name.trim().slice(0, 20);
  // Give each client a random-ish color
  myPlayer.preferredColor = randomColor();

  initSocket();
  setupHeartbeat();

  textFont('system-ui');
  textAlign(LEFT, TOP);
}

function windowResized() {
  resizeCanvas(windowWidth, windowHeight);
}

function randomColor() {
  const r = floor(random(80, 255)).toString(16).padStart(2, '0');
  const g = floor(random(80, 255)).toString(16).padStart(2, '0');
  const b = floor(random(80, 255)).toString(16).padStart(2, '0');
  return `#${r}${g}${b}`;
}

function initSocket() {
  socket = io();

  connectionStatus = 'connecting';

  socket.on('connect', () => {
    connectionStatus = 'connected';
    myPlayer.id = socket.id;
    // Join the lobby right away
    socket.emit('joinLobby', {
      name: myPlayer.name,
      preferredColor: myPlayer.preferredColor,
      timestamp: Date.now()
    });
  });

  socket.on('disconnect', () => {
    connectionStatus = 'disconnected';
  });

  // Lobby snapshot from server
  socket.on('lobbyState', data => {
    if (!data) return;
    lobbyState.spectators = data.spectators || [];
    lobbyState.activeMatches = data.activeMatches || [];
    lobbyState.globalStats = data.globalStats || lobbyState.globalStats;
    // If we're not in a match, make sure UI mode is lobby
    if (!currentMatch) {
      uiMode = 'lobby';
    }
  });

  // A new match has started for us
  socket.on('match_start', data => {
    if (!data) return;
    uiMode = 'match';
    currentMatch = {
      matchId: data.matchId,
      players: data.players || [],
      scores: data.scores || {},
      round: data.round || 1,
      startingPlayer: data.startingPlayer
    };
    hasSubmittedMoveThisRound = false;
    lastRoundResult = null;
  });

  // Turn / countdown info
  socket.on('turnUpdate', data => {
    if (!data) return;
    if (!currentMatch || currentMatch.matchId !== data.matchId) return;
    turnInfo.holderId = data.holderId;
    turnInfo.expiresAt = data.expiresAt;
    hasSubmittedMoveThisRound = false;
  });

  // Result of a round (revealed moves, scores, etc.)
  socket.on('round_result', data => {
    if (!data) return;
    if (!currentMatch || currentMatch.matchId !== data.matchId) return;
    currentMatch.round = data.round;
    currentMatch.scores = data.scores;
    lastRoundResult = {
      round: data.round,
      winnerId: data.winnerId,
      reason: data.reason,
      revealedMoves: data.revealedMoves,
      scores: data.scores
    };
    hasSubmittedMoveThisRound = false;
  });

  // Match end screen
  socket.on('game_end', data => {
    if (!data) return;
    // We briefly stay in match view, then we'll be sent back to lobby via new lobbyState
    // For now, we just keep currentMatch until lobbyState arrives. The server
    // requeues us, so soon we will be in a new match.
  });
}

// Periodic heartbeat to server so it can detect AFK / closed tabs
function setupHeartbeat() {
  setInterval(() => {
    if (socket && socket.connected) {
      socket.emit('heartbeat', { timestamp: Date.now() });
    }
  }, 5000);
}

// ---------------------------
// Main draw loop
// ---------------------------

function draw() {
  background(15);

  drawConnectionStatusBar();

  if (uiMode === 'lobby') {
    drawLobbyUI();
  } else if (uiMode === 'match') {
    drawMatchUI();
  }

  drawFooterInstructions();
}

function drawConnectionStatusBar() {
  // Simple status indicator at top
  const h = 32;
  noStroke();
  fill(20);
  rect(0, 0, width, h);

  let statusText = 'Connecting...';
  let statusColor = color(255, 215, 0);

  if (connectionStatus === 'connected') {
    statusText = 'Connected';
    statusColor = color(0, 255, 0);
  } else if (connectionStatus === 'disconnected') {
    statusText = 'Disconnected (trying to reconnect)';
    statusColor = color(255, 80, 80);
  }

  fill(statusColor);
  textSize(14);
  textAlign(LEFT, CENTER);
  text(statusText, 16, h / 2);

  // Show player name on the right
  fill(200);
  textAlign(RIGHT, CENTER);
  text(
    myPlayer.name ? `You: ${myPlayer.name}` : 'You: (unnamed)',
    width - 16,
    h / 2
  );
}

function drawLobbyUI() {
  const padding = 24;
  const topOffset = 40;

  // Title
  textAlign(LEFT, TOP);
  textSize(28);
  fill(240);
  text("Rock-Paper-Scissors Coliseum", padding, topOffset);

  textSize(14);
  fill(200);
  text("Waiting in lobby… You'll be auto-matched into 1v1 games.", padding, topOffset + 40);

  // Global stats
  const statsY = topOffset + 70;
  fill(180);
  text(
    `Total matches played: ${lobbyState.globalStats.totalMatchesPlayed || 0}\n` +
    `Total rounds played: ${lobbyState.globalStats.totalRoundsPlayed || 0}`,
    padding,
    statsY
  );

  // Spectator list
  const listY = statsY + 60;
  fill(220);
  textSize(18);
  text("Gladiators in Lobby", padding, listY);

  const lineHeight = 20;
  textSize(14);
  let y = listY + 28;
  lobbyState.spectators.forEach((p, i) => {
    const label = `${p.name}  (W: ${p.totalWins || 0}, L: ${p.totalLosses || 0})`;
    fill(180);
    text(label, padding, y + i * lineHeight);
  });

  // Active matches on the right
  const matchesX = width * 0.5;
  fill(220);
  textSize(18);
  text("Active Matches", matchesX, listY);

  y = listY + 28;
  lobbyState.activeMatches.forEach((m, i) => {
    const pA = m.players[0]?.name || "Player A";
    const pB = m.players[1]?.name || "Player B";
    const sA = m.scores[m.players[0]?.id] || 0;
    const sB = m.scores[m.players[1]?.id] || 0;
    fill(200);
    text(
      `${pA} (${sA}) vs ${pB} (${sB})`,
      matchesX,
      y + i * lineHeight
    );
  });
}

function drawMatchUI() {
  if (!currentMatch) {
    // If somehow we have no match but are in match mode, fallback
    uiMode = 'lobby';
    return;
  }

  const topOffset = 40;
  const padding = 24;

  // Title
  textAlign(CENTER, TOP);
  textSize(24);
  fill(240);
  text(`MATCH #${currentMatch.matchId.slice(-6)}`, width / 2, topOffset);

  // Players and scoreboard
  const [pA, pB] = currentMatch.players;
  const scoreA = currentMatch.scores[pA?.id] || 0;
  const scoreB = currentMatch.scores[pB?.id] || 0;

  const myId = socket ? socket.id : null;
  const isPlayerA = myId && pA && pA.id === myId;
  const isPlayerB = myId && pB && pB.id === myId;

  const nameA = pA ? pA.name : "Player A";
  const nameB = pB ? pB.name : "Player B";

  // Names
  textSize(16);
  textAlign(CENTER, TOP);
  fill(200);
  text(
    `${nameA}  (Score: ${scoreA})`,
    width * 0.25,
    topOffset + 40
  );
  text(
    `${nameB}  (Score: ${scoreB})`,
    width * 0.75,
    topOffset + 40
  );

  // Highlight "You"
  textSize(14);
  if (isPlayerA) {
    fill(120, 255, 120);
    text("(You)", width * 0.25, topOffset + 60);
  }
  if (isPlayerB) {
    fill(120, 255, 120);
    text("(You)", width * 0.75, topOffset + 60);
  }

  // Round info
  textAlign(CENTER, TOP);
  textSize(18);
  fill(220);
  text(`Round ${currentMatch.round}`, width / 2, topOffset + 90);

  // Turn + timer bar
  drawTurnTimerBar();

  // R/P/S buttons for your input
  drawRPSButtons();

  // Last round result panel (moves + win/lose)
  drawRoundResultPanel();
}

function drawTurnTimerBar() {
  const barWidth = width * 0.6;
  const barHeight = 16;
  const x = (width - barWidth) / 2;
  const y = 140;

  const now = Date.now();
  const remaining = max(0, turnInfo.expiresAt - now);
  const progress = constrain(remaining / 10000, 0, 1);

  noStroke();
  fill(40);
  rect(x, y, barWidth, barHeight, 8);

  if (progress > 0) {
    fill(120, 200, 255);
    rect(x, y, barWidth * progress, barHeight, 8);
  }

  // Text: who is acting + seconds remaining
  const holderId = turnInfo.holderId;
  const currentPlayer = currentMatch.players.find(p => p.id === holderId);
  const holderName = currentPlayer ? currentPlayer.name : 'Unknown';

  textAlign(CENTER, CENTER);
  textSize(12);
  fill(220);
  const seconds = (remaining / 1000).toFixed(1);
  text(
    `Turn: ${holderName}   •   Time left: ${seconds}s`,
    width / 2,
    y + barHeight + 14
  );
}

function drawRPSButtons() {
  const baseY = height - 160;
  const totalWidth = width * 0.6;
  const buttonWidth = totalWidth / 3 - 16;
  const buttonHeight = 80;
  const startX = (width - totalWidth) / 2;

  const labels = ['Rock', 'Paper', 'Scissors'];
  const moves = ['rock', 'paper', 'scissors'];

  rpsButtons = [];

  for (let i = 0; i < 3; i++) {
    const x = startX + i * (buttonWidth + 16);
    const y = baseY;
    rpsButtons.push({ x, y, w: buttonWidth, h: buttonHeight, move: moves[i] });

    const hover =
      mouseX >= x && mouseX <= x + buttonWidth &&
      mouseY >= y && mouseY <= y + buttonHeight;

    // Style: slightly glow if hover
    noStroke();
    fill(hover ? 70 : 45);
    rect(x, y, buttonWidth, buttonHeight, 10);

    // Label
    textAlign(CENTER, CENTER);
    textSize(18);
    fill(230);
    text(labels[i], x + buttonWidth / 2, y + buttonHeight / 2);
  }

  // Info text
  textAlign(CENTER, TOP);
  textSize(14);
  fill(190);
  text("Click one of the choices to lock in your move.", width / 2, baseY - 24);
}

function drawRoundResultPanel() {
  const panelWidth = width * 0.6;
  const panelHeight = 120;
  const x = (width - panelWidth) / 2;
  const y = 220;

  noStroke();
  fill(25);
  rect(x, y, panelWidth, panelHeight, 12);

  textAlign(LEFT, TOP);
  textSize(16);
  fill(230);
  text("Last Round", x + 16, y + 10);

  textSize(13);
  if (!lastRoundResult) {
    fill(180);
    text("No rounds resolved yet. Your move will be revealed once both players choose.", x + 16, y + 40);
    return;
  }

  const { winnerId, reason, revealedMoves } = lastRoundResult;

  let reasonText = '';
  if (reason === 'moves') reasonText = 'Normal resolution';
  else if (reason === 'timeout') reasonText = 'Timeout: inactive player lost';
  else if (reason === 'disconnect') reasonText = 'Opponent disconnected';
  else if (reason === 'forfeit') reasonText = 'Someone forfeited';

  const myId = socket ? socket.id : null;
  let outcome = 'Tie';
  if (winnerId && myId) {
    if (winnerId === myId) outcome = 'You won!';
    else outcome = 'You lost!';
  }

  fill(200);
  text(`Outcome: ${outcome}`, x + 16, y + 40);
  text(`Reason: ${reasonText}`, x + 16, y + 60);

  if (revealedMoves) {
    const movesText = Object.entries(revealedMoves)
      .map(([pid, move]) => {
        const p = currentMatch.players.find(pl => pl.id === pid);
        const name = p ? p.name : 'Unknown';
        return `${name}: ${move || 'no move'}`;
      })
      .join("   •   ");

    text(`Moves: ${movesText}`, x + 16, y + 80);
  }
}

function drawFooterInstructions() {
  const footerY = height - 28;
  noStroke();
  fill(20);
  rect(0, footerY, width, 28);

  textAlign(CENTER, CENTER);
  textSize(12);
  fill(180);
  if (uiMode === 'lobby') {
    text("Lobby: you will automatically be paired into 1v1 matches as other players join.", width / 2, footerY + 14);
  } else if (uiMode === 'match') {
    text("Match: click Rock / Paper / Scissors to make your choice. Press 'L' to forfeit and leave the match.", width / 2, footerY + 14);
  }
}

// ---------------------------
// Input handling
// ---------------------------

function mousePressed() {
  if (uiMode === 'match') {
    handleRPSClick();
  }
}

function handleRPSClick() {
  if (!currentMatch || !socket || !socket.connected) return;

  const myId = socket.id;
  const isMyTurn = (turnInfo.holderId === myId);
  if (!isMyTurn) {
    // Not your turn; ignore click
    return;
  }

  if (hasSubmittedMoveThisRound) {
    return; // Already submitted a move this round
  }

  for (const btn of rpsButtons) {
    if (
      mouseX >= btn.x && mouseX <= btn.x + btn.w &&
      mouseY >= btn.y && mouseY <= btn.y + btn.h
    ) {
      // Emit playerMove with timestamp
      socket.emit('playerMove', {
        matchId: currentMatch.matchId,
        move: btn.move,
        timestamp: Date.now()
      });
      hasSubmittedMoveThisRound = true;
      break;
    }
  }
}

function keyPressed() {
  if (!socket || !socket.connected) return;

  if (key === 'l' || key === 'L') {
    // Leave match / forfeit
    socket.emit('leaveMatch', {
      timestamp: Date.now()
    });
    // Locally, we go back to lobby view; server will also requeue us
    currentMatch = null;
    lastRoundResult = null;
    uiMode = 'lobby';
  }
}
</script>
</body>
</html>